import os
import yara
import csv
import hashlib
import binascii
import sys
import time
import re  # For natural sorting

# Configuration
SIGNATURES_FILE = "signatures.yar"
OUTPUT_CSV = "MP1_Scan_Results_new.csv"

# Sorting Order for CSV Grouping
FILE_TYPE_ORDER = [
    "JPEG-JFIF", "JPEG-EXIF", "JPEG",
    "PNG",
    "GIF87a", "GIF89a",
    "BMP",
    "PDF-1.4", "PDF-1.5", "PDF-1.6", "PDF-1.7", "PDF",
    "DOCX", "XLSX", "PPTX",
    "EXE-DOS", "EXE-x86", "EXE-x64", "EXE",
    "ZIP", "RAR", "7Z",
    "TXT", "CSV", "JSON", "XML", "HTML",
    "UNKNOWN"
]

class MalwareScanner:
    def __init__(self, rules_file):
        self.rules_file = rules_file
        self.detected_files = []
        self.compiled_rules = None
        self.type_counts = {}  # Counter for file types

    def compile_rules(self):
        print("[*] Compiling YARA rules...")
        if not os.path.exists(self.rules_file):
            print(f"[!] Critical Error: {self.rules_file} not found.")
            sys.exit(1)
        try:
            self.compiled_rules = yara.compile(filepath=self.rules_file)
            print("[*] Rules compiled successfully.")
        except yara.Error as e:
            print(f"[!] YARA Compilation Error: {e}")
            sys.exit(1)

    def calculate_hashes(self, filepath):
        """Streams file to calculate MD5 and SHA1 efficiently."""
        md5 = hashlib.md5()
        sha1 = hashlib.sha1()
        try:
            with open(filepath, 'rb') as f:
                while True:
                    chunk = f.read(8192) # 8KB chunks
                    if not chunk:
                        break
                    md5.update(chunk)
                    sha1.update(chunk)
            return md5.hexdigest(), sha1.hexdigest()
        except (PermissionError, IOError):
            return None, None

    def get_magic_bytes_hex(self, filepath):
        """Reads exactly first 50 bytes for verification column."""
        try:
            with open(filepath, 'rb') as f:
                return binascii.hexlify(f.read(50)).decode('utf-8').upper()
        except:
            return "READ_ERROR"

    def count_files_in_drive(self, drive_path):
        """Pre-counts files to calculate percentage."""
        print(f"[*] Calculating total files in {drive_path} (Please wait)...")
        total = 0
        try:
            for root, dirs, files in os.walk(drive_path):
                total += len(files)
        except Exception:
            pass
        return total

    def scan_drive(self, drive_path):
        # 1. Get total files for progress bar
        total_files = self.count_files_in_drive(drive_path)
        print(f"[*] Scanning Drive: {drive_path} (Total Files: {total_files})")
        
        file_counter = 0
        
        for root, dirs, files in os.walk(drive_path):
            try:
                for file in files:
                    file_counter += 1
                    full_path = os.path.join(root, file)

                    # --- CLEAN DISPLAY OUTPUT ---
                    # Shows: [25%] Scanning: filename.exe...
                    percent = 0
                    if total_files > 0:
                        percent = int((file_counter / total_files) * 100)
                    
                    # Truncate filename if it's too long for the terminal
                    display_name = (file[:35] + '..') if len(file) > 35 else file
                    sys.stdout.write(f"\r    [{percent}%] Scanning: {display_name:<40}")
                    sys.stdout.flush()

                    try:
                        # 1. YARA CHECK
                        matches = self.compiled_rules.match(full_path)
                        
                        if matches:
                            for match in matches:
                                meta = match.meta
                                
                                # 2. SIZE CHECK
                                target_size = meta.get('target_size')
                                current_size = os.path.getsize(full_path)
                                
                                if current_size != target_size:
                                    continue

                                # 3. HASH CHECK
                                found_md5, found_sha1 = self.calculate_hashes(full_path)
                                target_md5 = meta.get('target_md5')

                                if found_md5 == target_md5:
                                    file_type = meta.get('file_type', 'UNKNOWN')
                                    
                                    # Update Counter
                                    self.type_counts[file_type] = self.type_counts.get(file_type, 0) + 1

                                    # --- CLEAN TARGET FOUND MESSAGE ---
                                    # Clears the scanning line and prints a clean green-ish success message
                                    sys.stdout.write(f"\r    [+] FOUND: {file} ({file_type})                                \n")
                                    
                                    entry = {
                                        "File Name": file,
                                        "Hash MD5": found_md5,
                                        "Hash SHA1": found_sha1,
                                        "Directory": full_path,
                                        "File Type": file_type,
                                        "Magic Bytes": self.get_magic_bytes_hex(full_path)
                                    }
                                    self.detected_files.append(entry)
                                    break 
                                    
                    except Exception:
                        continue 
            except PermissionError:
                continue 
        print(f"\n    [v] Drive {drive_path} Complete.\n")

    def save_results(self):
        print(f"[*] Sorting {len(self.detected_files)} detected files...")

        def natural_sort_key(text):
            return [int(c) if c.isdigit() else c.lower() for c in re.split(r'(\d+)', text)]

        def sort_key(item):
            type_str = item["File Type"]
            try:
                type_index = FILE_TYPE_ORDER.index(type_str)
            except ValueError:
                type_index = 999 
            return (type_index, natural_sort_key(item["File Name"]))

        sorted_files = sorted(self.detected_files, key=sort_key)

        print(f"[*] Writing results to {OUTPUT_CSV}...")
        headers = ["File Name", "Hash MD5", "Hash SHA1", "Directory", "File Type", "Magic Bytes"]
        
        try:
            with open(OUTPUT_CSV, 'w', newline='', encoding='utf-8') as f:
                writer = csv.DictWriter(f, fieldnames=headers)
                writer.writeheader()
                writer.writerows(sorted_files)
                
                # --- ADDING SUMMARY COUNTER TO CSV ---
                writer = csv.writer(f)
                writer.writerow([])
                writer.writerow(["--- SCAN SUMMARY ---"])
                writer.writerow(["File Type", "Count"])
                for ftype, count in self.type_counts.items():
                    writer.writerow([ftype, count])
                writer.writerow(["Total Detected", len(self.detected_files)])

            print(f"[*] SCAN COMPLETE. Results saved to {OUTPUT_CSV}")
            
            # Print Summary to Terminal
            print("\n    --- FINAL SUMMARY ---")
            for ftype, count in self.type_counts.items():
                print(f"    {ftype}: {count}")
            print(f"    Total: {len(self.detected_files)}")

        except IOError as e:
            print(f"[!] Error writing CSV: {e}")

if __name__ == "__main__":
    scanner = MalwareScanner(SIGNATURES_FILE)
    scanner.compile_rules()
    
    # Auto-detect drives 
    drives_to_scan = []
    
    for drive_letter in "DEFGHI": 
        drive = f"{drive_letter}:\\"
        if os.path.exists(drive):
            drives_to_scan.append(drive)

    print(f"[*] Target Drives: {drives_to_scan}")
    
    start_time = time.time()
    
    for drive in drives_to_scan:
        if os.path.exists(drive):
            scanner.scan_drive(drive)

    scanner.save_results()
    print(f"[*] Time Elapsed: {round((time.time() - start_time)/60, 2)} minutes")